@page "/movies"
@using Microsoft.AspNetCore.Components.Web.Virtualization
@inject IMovieService MovieService
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer
@implements IAsyncDisposable

<PageTitle>Virtualized Table</PageTitle>

@if (false) { }
else
{
    <div>
        <Virtualize @ref="virtualizeComponent" ItemsProvider="@LoadMovieRows" Context="row">
            <ItemContent>
                <div class="movie-row">
                    @foreach (var movie in row)
                    {
                        <div class="movie-card" @onclick="() => ShowMovieDetail(movie)">
                            <img src="@movie.CoverUrl" alt="@movie.Title" />
                            <div class="movie-title">@movie.Title</div>
                        </div>
                    }
                    @* Fill remaining space with invisible items to maintain alignment *@
                    @for (int i = 0; i < ItemsPerRow - row.Count; i++)
                    {
                        <div class="movie-card" style="visibility: hidden;"></div>
                    }
                </div>
            </ItemContent>
            <Placeholder>
                <div class="movie-row placeholder">
                    Loading...
                </div>
            </Placeholder>
        </Virtualize>
    </div>

    @if (selectedMovie != null)
    {
        <div class="modal-overlay" @onclick="CloseModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <h2>@selectedMovie.Title</h2>
                <img src="@selectedMovie.CoverUrl" alt="@selectedMovie.Title" style="max-width: 100%; height: auto;" />
                @if (selectedMovie.OriginCountries.Count > 0)
                {
                    <p class="movie-origin">Origin: @string.Join(", ", selectedMovie.OriginCountries)</p>
                }
                <p>@selectedMovie.Synopsis</p>

                @if (selectedSchedules != null && selectedSchedules.Count > 0)
                {
                    <h3>Upcoming schedules</h3>
                    @foreach (var kv in selectedSchedules.OrderBy(k => k.Key))
                    {
                        <div class="schedule-day">
                            @{
                                var today = DateOnly.FromDateTime(DateTime.UtcNow);
                                string dateLabel;
                                if (kv.Key == today)
                                {
                                    dateLabel = "Today";
                                }
                                else if (kv.Key == today.AddDays(1))
                                {
                                    dateLabel = "Tomorrow";
                                }
                                else
                                {
                                    dateLabel = kv.Key.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc).ToString("dddd");
                                }
                            }
                            <h4>@dateLabel (@kv.Key.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc).ToString("yyyy-MM-dd"))</h4>
                            @foreach (var schedule in kv.Value)
                            {
                                <div class="schedule-entry">
                                    <div class="schedule-date">@((kv.Key == today) ? "Today" : (kv.Key == today.AddDays(1) ? "Tomorrow" : kv.Key.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc).ToString("dddd yyyy-MM-dd")))</div>
                                    @foreach (var perf in schedule.Performances)
                                    {
                                        <div class="performance">
                                            <div class="performance-header">
                                                <div class="performance-date">@((kv.Key == today) ? "Today" : (kv.Key == today.AddDays(1) ? "Tomorrow" : kv.Key.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc).ToString("dddd yyyy-MM-dd")))</div>
                                                <div class="venue">@((perf.Venue?.Name) ?? $"Venue #{perf.VenueId}")</div>
                                            </div>
                                            <div class="showtimes">
                                                @foreach (var st in perf.Showtimes)
                                                {
                                                    <span class="showtime">@st.StartAt.ToLocalTime().ToString("HH:mm")</span>
                                                }
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                }
                else
                {
                    <p>No upcoming schedules available.</p>
                }

                <button @onclick="CloseModal">Close</button>
            </div>
        </div>
    }
}

@code {
    private Movie? selectedMovie;
    private Dictionary<DateOnly, List<Schedule>>? selectedSchedules;
    private int ItemsPerRow = 4;
    private Virtualize<List<Movie>>? virtualizeComponent;
    private DotNetObjectReference<Movies>? selfReference;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            selfReference = DotNetObjectReference.Create(this);
            // Inject a simple resize handler
            await JSRuntime.InvokeVoidAsync("eval", @"
                window.resizeListener = (dotnetHelper) => {
                    const handler = () => {
                         dotnetHelper.invokeMethodAsync('OnResize', window.innerWidth);
                    };
                    window.addEventListener('resize', handler);
                    handler(); // Initial call
                };
            ");
            await JSRuntime.InvokeVoidAsync("resizeListener", selfReference);
        }
    }

    [JSInvokable]
    public async Task OnResize(int width)
    {
        // Card width 200px + 20px gap + extra padding buffer
        // (Width - 40px padding) / 220px stride
        var newItemsPerRow = Math.Max(1, (width - 40) / 220);
        
        if (newItemsPerRow != ItemsPerRow)
        {
            ItemsPerRow = newItemsPerRow;
            if (virtualizeComponent != null)
            {
                await virtualizeComponent.RefreshDataAsync();
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    private async ValueTask<ItemsProviderResult<List<Movie>>> LoadMovieRows(ItemsProviderRequest request)
    {
        var totalMovies = await MovieService.GetTotalMovieCountWithFutureSchedules();
        var totalRows = (int)Math.Ceiling(totalMovies / (double)ItemsPerRow);

        var startIndex = request.StartIndex * ItemsPerRow;
        var count = Math.Min(request.Count * ItemsPerRow, Math.Max(0, totalMovies - startIndex));
        
        if (count <= 0)
        {
             return new ItemsProviderResult<List<Movie>>(new List<List<Movie>>(), totalRows);
        }

        var movies = await MovieService.GetMoviesWithFutureSchedules(startIndex, count);
        var rows = new List<List<Movie>>();
        
        for (int i = 0; i < movies.Count; i += ItemsPerRow)
        {
            // Take up to ItemsPerRow, handle end of list
            rows.Add(movies.Skip(i).Take(ItemsPerRow).ToList());
        }

        return new ItemsProviderResult<List<Movie>>(rows, totalRows);
    }

    private async Task ShowMovieDetail(Movie movie)
    {
        selectedMovie = movie;
        selectedSchedules = await MovieService.GetUpcomingSchedulesForMovie(movie.Id, 14);
        await InvokeAsync(StateHasChanged);
    }

    private void CloseModal()
    {
        selectedMovie = null;
        selectedSchedules = null;
    }

    public async ValueTask DisposeAsync()
    {
        if (selfReference != null)
        {
            // Cleanup standard event listener would require keeping the function reference in JS
            // For this quick implementation, we rely on page refresh clearing it
            selfReference.Dispose();
        }
    }
}
